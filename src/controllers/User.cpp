/**
 *
 *  User.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "User.h"

#include <string>
#include "bcrypt/bcrypt.h"
#include "jwt/JWT.h"
#include "uuid/UtilUUID.h"

namespace api::v1
{

	void User::login(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)
	{
		auto jsonPtr = req->getJsonObject();

		if (!jsonPtr || !jsonPtr->isMember("account") || !jsonPtr->isMember("pwd"))
		{
			Json::Value resultJson;
			resultJson["code"] = k400BadRequest;
			resultJson["msg"] = "Missing account or password.";
			return callback(HttpResponse::newHttpJsonResponse(resultJson));
		}

		auto callbackPtr =
				std::make_shared<std::function<void(const HttpResponsePtr &)>>(
						std::move(callback));
		auto dbClientPtr = getDbClient();
		Mapper<Users> mapper(dbClientPtr);

		mapper.findOne(
				Criteria(Users::Cols::_account, CompareOperator::EQ, (*jsonPtr)["account"]),
				[req, jsonPtr, callbackPtr, this](const Users &user)
				{
					Json::Value resultJson;
					if (!Utils::Bcrypt::compare((*jsonPtr)["pwd"].asString(), user.getPwd()->data()))
					{
						// Compare password hash.
						resultJson["code"] = k403Forbidden;
						resultJson["msg"] = "Incorrect password.";
						return (*callbackPtr)(HttpResponse::newHttpJsonResponse(resultJson));
					}

					try
					{
						auto userJson = makeJson(req, user);

						Utils::jwt::JWT jwtGenerated = Utils::jwt::JWT::generateToken(
								{
										{"userid", picojson::value(userJson["id"].asInt64())},
								},
								jsonPtr->isMember("member") && (*jsonPtr)["member"].asBool());

						auto token = jwtGenerated.getToken();
						auto uuid = Utils::uuid::genUUID();

						try
						{
							auto redisClientPtr = getRedisClient();
							redisClientPtr->execCommandSync<std::string>(
									[](const nosql::RedisResult &r)
									{
										return r.asString();
									},
									"set %s %s", uuid.data(), token.data());

							userJson.removeMember("pwd");

							resultJson["code"] = k200OK;
							resultJson["token"] = uuid;
							resultJson["data"] = userJson;
							return (*callbackPtr)(HttpResponse::newHttpJsonResponse(resultJson));
						}
						catch (const nosql::RedisException &err)
						{
							LOG_ERROR << err.what();
							Json::Value ret;
							ret["code"] = k500InternalServerError;
							ret["msg"] = err.what();
							auto resp = HttpResponse::newHttpJsonResponse(ret);
							resp->setStatusCode(k500InternalServerError);
							return (*callbackPtr)(resp);
						}
					}
					catch (const std::exception &e)
					{
						LOG_ERROR << e.what();
						Json::Value ret;
						ret["code"] = k500InternalServerError;
						ret["msg"] = e.what();
						auto resp = HttpResponse::newHttpJsonResponse(ret);
						resp->setStatusCode(k500InternalServerError);
						return (*callbackPtr)(resp);
					}
				},
				[callbackPtr](const DrogonDbException &e)
				{
					LOG_ERROR << e.base().what();
					Json::Value resultJson;
					resultJson["code"] = k500InternalServerError;
					resultJson["msg"] = "database error";
					return (*callbackPtr)(HttpResponse::newHttpJsonResponse(resultJson));
				});
	}

}