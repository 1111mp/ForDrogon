/**
 *
 *  User.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "User.h"

#include <string>
#include "bcrypt/bcrypt.h"
#include "jwt/JWT.h"
#include "uuid/UtilUUID.h"

namespace api::v1
{

	void User::login(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)
	{
		auto jsonPtr = req->getJsonObject();

		if (!jsonPtr || !jsonPtr->isMember("account") || !jsonPtr->isMember("pwd"))
		{
			Json::Value resultJson;
			resultJson["code"] = k400BadRequest;
			resultJson["msg"] = "Missing account or password.";
			return callback(HttpResponse::newHttpJsonResponse(resultJson));
		}

		auto callbackPtr =
				std::make_shared<std::function<void(const HttpResponsePtr &)>>(
						std::move(callback));
		auto dbClientPtr = getDbClient();
		Mapper<Users> mapper(dbClientPtr);

		mapper.findOne(
				Criteria(Users::Cols::_account, CompareOperator::EQ, (*jsonPtr)["account"]),
				[req, jsonPtr, callbackPtr, this](const Users &user)
				{
					if (!Utils::Bcrypt::compare((*jsonPtr)["pwd"].asString(), user.getPwd()->data()))
					{
						// Compare password hash.
						Json::Value resultJson;
						resultJson["code"] = k403Forbidden;
						resultJson["msg"] = "Incorrect account or password.";
						return (*callbackPtr)(HttpResponse::newHttpJsonResponse(resultJson));
					}

					try
					{
						auto userJson = user.toJson();
						userJson.removeMember("pwd");

						Utils::jwt::JWT jwtGenerated = Utils::jwt::JWT::generateToken(
								{
										{"userid", picojson::value(userJson["id"].asInt64())},
								},
								jsonPtr->isMember("member") && (*jsonPtr)["member"].asBool());

						auto token = jwtGenerated.getToken();
						auto uuid = Utils::uuid::genUUID();

						auto redisClientPtr = getRedisClient();

						redisClientPtr->newTransactionAsync(
								[uuid, token, userJson, callbackPtr](const nosql::RedisTransactionPtr &transPtr)
								{
									auto auth = app().getCustomConfig()["redis"]["auth_key"].asString() + "_" + userJson["id"].asString();

									transPtr->execCommandAsync(
											[](const drogon::nosql::RedisResult &r) { /* this command works */ },
											[](const std::exception &err) { /* this command failed */ },
											"del %s", auth.data());

									transPtr->execCommandAsync(
											[](const nosql::RedisResult &r) { /* this command works */ },
											[](const std::exception &err) { /* this command failed */ },
											"hset %s %s %s", auth.data(), uuid.data(), token.data());

									transPtr->execute(
											[uuid, userJson, callbackPtr](const drogon::nosql::RedisResult &r)
											{
												Json::Value resultJson;
												resultJson["code"] = k200OK;
												resultJson["token"] = uuid;
												resultJson["data"] = userJson;
												return (*callbackPtr)(HttpResponse::newHttpJsonResponse(resultJson));
											},
											[callbackPtr](const std::exception &err)
											{
												LOG_ERROR << err.what();
												Json::Value ret;
												ret["code"] = k500InternalServerError;
												ret["msg"] = err.what();
												auto resp = HttpResponse::newHttpJsonResponse(ret);
												resp->setStatusCode(k500InternalServerError);
												return (*callbackPtr)(resp);
											});
								});
					}
					catch (const std::exception &e)
					{
						LOG_ERROR << e.what();
						Json::Value ret;
						ret["code"] = k500InternalServerError;
						ret["msg"] = e.what();
						auto resp = HttpResponse::newHttpJsonResponse(ret);
						resp->setStatusCode(k500InternalServerError);
						return (*callbackPtr)(resp);
					}
				},
				[callbackPtr](const DrogonDbException &e)
				{
					LOG_ERROR << e.base().what();
					Json::Value resultJson;
					resultJson["code"] = k500InternalServerError;
					resultJson["msg"] = "database error.";
					return (*callbackPtr)(HttpResponse::newHttpJsonResponse(resultJson));
				});
	}

	void User::logout(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)
	{
		auto userID = req->getAttributes()->get<std::string>("jwt_userid");
		auto redisClientPtr = getRedisClient();
		auto auth = app().getCustomConfig()["redis"]["auth_key"].asString() + "_" + userID;

		redisClientPtr->execCommandAsync(
				[callback](const nosql::RedisResult &r)
				{
					Json::Value resultJson;
					resultJson["code"] = k200OK;
					resultJson["msg"] = "Sign out successfully.";
					return callback(HttpResponse::newHttpJsonResponse(resultJson));
				},
				[callback](const std::exception &err)
				{
					LOG_ERROR << err.what();
					Json::Value resultJson;
					resultJson["code"] = k500InternalServerError;
					resultJson["msg"] = err.what();
					return callback(HttpResponse::newHttpJsonResponse(resultJson));
				},
				"del %s", auth.data());
	}

	void User::registerHandler(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)
	{
		auto jsonPtr = req->getJsonObject();
		if (!jsonPtr || !jsonPtr->isMember("account") || !jsonPtr->isMember("pwd"))
		{
			Json::Value resultJson;
			resultJson["code"] = k400BadRequest;
			resultJson["msg"] = "Missing account or password.";
			return callback(HttpResponse::newHttpJsonResponse(resultJson));
		}

		auto dbClientPtr = getDbClient();
		Mapper<Users> mapper(dbClientPtr);
		auto now = trantor::Date::now().toDbStringLocal();
		LOG_INFO << "Now: " << now;
		(*jsonPtr)["registime"] = (*jsonPtr)["updatetime"] = now;
		Users object = Users(*jsonPtr);
		auto callbackPtr =
				std::make_shared<std::function<void(const HttpResponsePtr &)>>(
						std::move(callback));
		mapper.insert(
				object,
				[req, jsonPtr, callbackPtr, this](Users user)
				{
					auto userJson = user.toJson();
					userJson.removeMember("pwd");

					Utils::jwt::JWT jwtGenerated = Utils::jwt::JWT::generateToken(
							{
									{"userid", picojson::value(userJson["id"].asInt64())},
							},
							jsonPtr->isMember("member") && (*jsonPtr)["member"].asBool());

					auto token = jwtGenerated.getToken();
					auto uuid = Utils::uuid::genUUID();

					auto redisClientPtr = getRedisClient();
					auto auth = app().getCustomConfig()["redis"]["auth_key"].asString() + "_" + userJson["id"].asString();

					redisClientPtr->execCommandAsync(
							[uuid, userJson, callbackPtr](const drogon::nosql::RedisResult &r)
							{
								Json::Value resultJson;
								resultJson["code"] = k200OK;
								resultJson["token"] = uuid;
								resultJson["data"] = userJson;
								return (*callbackPtr)(HttpResponse::newHttpJsonResponse(resultJson));
							},
							[callbackPtr](const std::exception &err)
							{
								LOG_ERROR << err.what();
								Json::Value resultJson;
								resultJson["code"] = k500InternalServerError;
								resultJson["msg"] = err.what();
								auto resp = HttpResponse::newHttpJsonResponse(resultJson);
								resp->setStatusCode(k500InternalServerError);
								return (*callbackPtr)(resp);
							},
							"hset %s %s %s", auth.data(), uuid.data(), token.data());
				},
				[callbackPtr](const DrogonDbException &err)
				{
					LOG_ERROR << err.base().what();
					Json::Value resultJson;
					resultJson["code"] = k500InternalServerError;
					resultJson["msg"] = err.base().what();
					auto resp = HttpResponse::newHttpJsonResponse(resultJson);
					resp->setStatusCode(k500InternalServerError);
					return (*callbackPtr)(resp);
				});
	}

}