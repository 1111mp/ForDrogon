/**
 *
 *  UserCtrl.cpp
 *  This file is generated by drogon_ctl
 *
 */

#include "UserCtrl.h"

#include <string>
#include "bcrypt/bcrypt.h"
#include "jwt/JWT.h"
#include "UUID/UtilUUID.h"
#include "common/Common.h"

namespace api::v1
{

	Task<void> User::login(const HttpRequestPtr req, std::function<void(const HttpResponsePtr &)> callback)
	{
		auto jsonPtr = req->getJsonObject();

		if (!jsonPtr || !jsonPtr->isMember("account") || !jsonPtr->isMember("pwd"))
		{
			auto resp = Utils::Common::makeHttpJsonResponse(k400BadRequest, "Missing account or password.");
			callback(resp);
			co_return;
		}

		auto dbClientPtr = getDbClient();
		CoroMapper<Users> mapper(dbClientPtr);

		try
		{
			auto user = co_await mapper.findOne(Criteria(Users::Cols::_account, CompareOperator::EQ, (*jsonPtr)["account"]));

			if (!Utils::Bcrypt::compare((*jsonPtr)["pwd"].asString(), user.getPwd()->data()))
			{
				// Compare password hash.
				auto resp = Utils::Common::makeHttpJsonResponse(k403Forbidden, "Incorrect account or password.");
				callback(resp);
				co_return;
			}

			auto userJson = user.toJson();
			userJson.removeMember("pwd");
			auto member = jsonPtr->isMember("member") && (*jsonPtr)["member"].asBool();
			auto userid = userJson["id"].asInt64();

			try
			{
				Utils::jwt::JWT jwtGenerated = Utils::jwt::JWT::generateToken(
						{
								{"userid", picojson::value(userJson["id"].asInt64())},
								{"member", picojson::value(member)},
						},
						member);

				auto token = jwtGenerated.getToken();
				auto uuid = Utils::uuid::genUUID();
				auto expiresAt = member ? jwtGenerated.getExpiration() : 3600;
				auto auth = app().getCustomConfig()["redis"]["auth_key"].asString() + "_" + userJson["id"].asString();
				auto redisClientPtr = getRedisClient();

				auto transPtr = co_await redisClientPtr->newTransactionCoro();
				co_await transPtr->execCommandCoro("del %s", auth.data());
				co_await transPtr->execCommandCoro("hset %s %s %s", auth.data(), uuid.data(), token.data());
				co_await transPtr->execCommandCoro("expire %s %lld", auth.data(), expiresAt);
				co_await transPtr->executeCoro();

				userJson["token"] = uuid;
				auto resp = Utils::Common::makeHttpJsonResponse(k200OK, "", userJson);
				callback(resp);
				co_return;
			}
			catch (const std::exception &err)
			{
				LOG_ERROR << err.what();
				auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, err.what());
				callback(resp);
				co_return;
			}
		}
		catch (const DrogonDbException &err)
		{
			const orm::UnexpectedRows *s = dynamic_cast<const orm::UnexpectedRows *>(&err.base());
			if (s)
			{
				auto resp = HttpResponse::newHttpResponse();
				resp->setStatusCode(k404NotFound);
				callback(resp);
				co_return;
			}
			LOG_ERROR << err.base().what();
			auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, "database error.");
			callback(resp);
			co_return;
		}
	}

	Task<void> User::logout(const HttpRequestPtr req, std::function<void(const HttpResponsePtr &)> callback)
	{
		auto userID = req->getAttributes()->get<int64_t>("jwt_userid");
		auto redisClientPtr = getRedisClient();
		auto auth = app().getCustomConfig()["redis"]["auth_key"].asString() + "_" + std::to_string(userID);

		try
		{
			co_await redisClientPtr->execCommandCoro("del %s", auth.data());

			auto resp = Utils::Common::makeHttpJsonResponse(k200OK, "Sign out successfully.");
			callback(resp);
		}
		catch (const std::exception &err)
		{
			LOG_ERROR << err.what();
			auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, err.what());
			callback(resp);
		}
		co_return;
	}

	Task<void> User::create(const HttpRequestPtr req, std::function<void(const HttpResponsePtr &)> callback)
	{
		auto jsonPtr = req->getJsonObject();
		if (!jsonPtr || !jsonPtr->isMember("account") || !jsonPtr->isMember("pwd"))
		{
			auto resp = Utils::Common::makeHttpJsonResponse(k400BadRequest, "Missing account or password.");
			callback(resp);
			co_return;
		}

		Users object = Users(*jsonPtr);
		auto now = trantor::Date::now();
		object.setRegistime(now);
		object.setUpdatetime(now);

		auto dbClientPtr = getDbClient();
		CoroMapper<Users> mapper(dbClientPtr);

		try
		{
			auto user = co_await mapper.insert(object);
			auto userJson = user.toJson();
			userJson.removeMember("pwd");
			auto member = jsonPtr->isMember("member") && (*jsonPtr)["member"].asBool();

			try
			{
				Utils::jwt::JWT jwtGenerated = Utils::jwt::JWT::generateToken(
						{
								{"userid", picojson::value(userJson["id"].asInt64())},
								{"member", picojson::value(member)},
						},
						member);

				auto token = jwtGenerated.getToken();
				auto uuid = Utils::uuid::genUUID();
				auto expiresAt = member ? jwtGenerated.getExpiration() : 3600;
				auto auth = app().getCustomConfig()["redis"]["auth_key"].asString() + "_" + userJson["id"].asString();

				auto redisClientPtr = getRedisClient();
				auto transPtr = co_await redisClientPtr->newTransactionCoro();
				co_await transPtr->execCommandCoro("hset %s %s %s", auth.data(), uuid.data(), token.data());
				co_await transPtr->execCommandCoro("expire %s %lld", auth.data(), expiresAt);
				co_await transPtr->executeCoro();

				userJson["token"] = uuid;
				auto resp = Utils::Common::makeHttpJsonResponse(k200OK, "", userJson);
				callback(resp);
				co_return;
			}
			catch (const std::exception &err)
			{
				LOG_ERROR << err.what();
				auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, err.what());
				callback(resp);
				co_return;
			}
		}
		catch (const DrogonDbException &err)
		{
			const orm::UniqueViolation *s = dynamic_cast<const orm::UniqueViolation *>(&err.base());
			if (s)
			{
				auto resp = Utils::Common::makeHttpJsonResponse(k409Conflict, "The account already exists.");
				callback(resp);
				co_return;
			}

			LOG_ERROR << err.base().what();
			auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, "database error.");
			callback(resp);
			co_return;
		}
	}

	Task<void> User::deleteOne(const HttpRequestPtr req, std::function<void(const HttpResponsePtr &)> callback)
	{
		auto userID = req->getAttributes()->get<int64_t>("jwt_userid");
		auto auth = app().getCustomConfig()["redis"]["auth_key"].asString() + "_" + std::to_string(userID);

		auto dbClientPtr = getDbClient();
		CoroMapper<Users> mapper(dbClientPtr);

		try
		{
			auto count = co_await mapper.deleteByPrimaryKey(userID);

			if (count == 1)
			{
				auto redisClientPtr = getRedisClient();
				co_await redisClientPtr->execCommandCoro("del %s", auth.data());

				auto resp = Utils::Common::makeHttpJsonResponse(k200OK, "Successfully.");
				callback(resp);
			}
			else if (count == 0)
			{
				auto resp = Utils::Common::makeHttpJsonResponse(k404NotFound, "No resources deleted.");
				callback(resp);
			}
			else
			{
				LOG_FATAL << "Delete more than one records: " << count;
				auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, "Something error.");
				callback(resp);
			}
		}
		catch (const DrogonDbException &err)
		{
			auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, "Database error.");
			callback(resp);
		}
		co_return;
	}

	Task<void> User::updateOne(const HttpRequestPtr req, std::function<void(const HttpResponsePtr &)> callback)
	{
		auto jsonPtr = req->jsonObject();
		auto id = req->getAttributes()->get<int64_t>("jwt_userid");
		if (!jsonPtr)
		{
			auto resp = Utils::Common::makeHttpJsonResponse(k400BadRequest, "No json object is found in the request.");
			callback(resp);
			co_return;
		}

		(*jsonPtr)["id"] = id;

		Users object;
		object.setUpdatetime(trantor::Date::now());
		try
		{
			std::string err;
			if (!Users::validateJsonForUpdate(*jsonPtr, err))
			{
				auto resp = Utils::Common::makeHttpJsonResponse(k400BadRequest, err);
				callback(resp);
				co_return;
			}
			object.updateByJson(*jsonPtr);
		}
		catch (const std::exception &e)
		{
			LOG_ERROR << e.what();
			auto resp = Utils::Common::makeHttpJsonResponse(k400BadRequest, "Field type error.");
			callback(resp);
			co_return;
		}

		auto dbClientPtr = getDbClient();
		CoroMapper<Users> mapper(dbClientPtr);

		try
		{
			auto count = co_await mapper.update(object);
			if (count == 1)
			{
				auto resp = Utils::Common::makeHttpJsonResponse(k200OK, "Update successed.");
				callback(resp);
			}
			else if (count == 0)
			{
				auto resp = Utils::Common::makeHttpJsonResponse(k404NotFound, "No resources are updated.");
				callback(resp);
			}
			else
			{
				LOG_FATAL << "More than one resource is updated: " << count;
				auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, "database error.");
				callback(resp);
			}
		}
		catch (const DrogonDbException &err)
		{
			LOG_ERROR << err.base().what();
			auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, "database error.");
			callback(resp);
		}
		co_return;
	}

	Task<void> User::getOne(const HttpRequestPtr req, std::function<void(const HttpResponsePtr &)> callback, Users::PrimaryKeyType id)
	{
		auto dbClientPtr = getDbClient();
		CoroMapper<Users> mapper(dbClientPtr);

		try
		{
			auto userJson = (co_await mapper.findByPrimaryKey(id)).toJson();
			userJson.removeMember("pwd");

			auto resp = Utils::Common::makeHttpJsonResponse(k200OK, "", userJson);
			callback(resp);
		}
		catch (const DrogonDbException &err)
		{
			const orm::UnexpectedRows *s = dynamic_cast<const orm::UnexpectedRows *>(&err.base());
			if (s)
			{
				auto resp = Utils::Common::makeHttpJsonResponse(k404NotFound, "User[" + std::to_string(id) + "] not found.");
				callback(resp);
				co_return;
			}
			LOG_ERROR << err.base().what();
			auto resp = Utils::Common::makeHttpJsonResponse(k500InternalServerError, "database error.");
			callback(resp);
		}
		co_return;
	}

}